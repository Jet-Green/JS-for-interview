# Регулярные выражения *RegExp*
### Они позволяют находить подстроки в строке. Выглядят они как речь пришельцев, но могут сильно облегчить жизнь.
### В JS они создаются 2 способами:
```js
let regexLiteral = /cat/;
// или
var regexConstructor = new RegExp("cat");
```
### Один из основных методов регулярных выражения — это `.test()`, который возвращает логическое значение:
```js
let s1 = 'cat says meow'
let s2 = 'dog says bark!!!'

const hasBark = /bark/;

hasBark.test(s1);
hasBark.test(s2);
```
### Первый тест вернёт `false`, 2 - `true`
### Например: `/^[A-Z]+$/` может определить состоит ли строка только из заглавных латинских букв.
### Базовые конструкции:
### Символы:
 - `.` (точка) — соответствует любому одиночному символу за исключением переноса строки.
 - `^` — соответствует началу строки.
 - `$` — соответствует концу строки.



### Квантификаторы:
 - `*` — соответствует предыдущему выражению, которое повторено 0 или более раз.
 - `+` — соответствует предыдущему выражению, которое повторено 1 или более раз.
 - `?` — соответствует предыдущему выражению, повторённому 0 или 1 раз.
 - `{n}` - количество символов можно указать в `n`.



### Группы символов
 - `\d` — соответствует любому одиночному цифровому символу.
 - `\w` — соответствует любому символу — цифре, букве, или знаку подчёркивания.
 - `[XYZ]` — набор символов. Соответствует любому одиночному символу из набора, заданного в скобках. Кроме того, похожим образом можно задавать и диапазоны символов, например — `[A-Z]`.
 - `[XYZ]+` — соответствует символу из скобок, повторённому один или более раз.
 - `[^A-Z]` — внутри выражений, задающих диапазоны символов, символ ^ используется как знак отрицания. В данном примере шаблону соответствует всё, что не является буквами в верхнем регистре.



### Флаги
### Размещаются после последнего слеша. `/[A-Z]/g` - в данном случае `g` - флаг.
- `g` — глобальный поиск по строке.
- `i` — поиск, нечувствительный к регистру.
### Дополнительные конструкции
- `(x)` — захватывающие скобки. Это выражение соответствует `x` и запоминает это соответствие, в результате, мы можем воспользоваться им позже.
- `(?:x)` — незахватывающие скобки. Выражение соответствует `x`, но не запоминает это соответствие
- `x(?=y)` — упреждающее соответствие. Соответствует `x` только если за ним следует `y`.



### Скобочные группы:
### Часть шаблона можно заключить в скобки `(...)`. 
### У такого выделения есть два эффекта:
1) Позволяет поместить часть совпадения в отдельный массив.
2) Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобки, а не к одному символу.
### Например:
```js
let regexp = /(go)+/
console.log('gogogo now!'.match(regexp))
```
### Результат: `gogogo`



### Экранирование символов
### Символы, уже используемые в реулярках, как служебные, например `+` `?` `<` `>`, нужно экранировать с помощью обратного слеша.



### Другие методы *RegExp*:
### `str.match(regexp)`
У него есть три режима работы:
1) Если у регулярного выражения нет флага `g`, то он возвращает первое совпадение в виде массива со скобочными группами и свойствами `index` (позиция совпадения), `input` (строка поиска, равна `str`):
2) Если у регулярного выражения есть флаг `g`, то он возвращает массив всех совпадений, без скобочных групп и других деталей.
3) Если совпадений нет, то, вне зависимости от наличия флага `g`, возвращается `null`.
### `str.matchAll(regexp)`
### Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.
### У него 3 отличия от match:
1) Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи `Array.from`.
2) Каждое совпадение возвращается в виде массива со скобочными группами (как `str.match` без флага `g`).
3) Если совпадений нет, то возвращается не `null`, а пустой перебираемый объект.
### `str.split(regexp|substr, limit)`
### Разбивает строку в массив по разделителю – регулярному выражению `regexp` или подстроке `substr`.
### `str.search(regexp)`
### Возвращает позицию *только* первого совпадения с `regexp` в строке `str` или `-1`, если совпадения нет.
### `str.replace(str|regexp, str|func)`
### Это универсальный метод поиска-и-замены, один из самых полезных.
```js
'12-34-56'.replace( /-/g, ":")
```
### Результат: `12:34:56`
### `regexp.exec(str)`
### Ищет совпадение с `regexp` в строке `str`. В отличие от предыдущих методов, вызывается на регулярном выражении, а не на строке.
### Если нет `g`, то `regexp.exec(str)` возвращает первое совпадение в точности как `str.match(regexp)`. Такое поведение не даёт нам ничего нового.
### Но если есть `g`, то:
- Вызов `regexp.exec(str)` возвращает первое совпадение и запоминает позицию после него в свойстве `regexp.lastIndex`.
- Следующий такой вызов начинает поиск с позиции `regexp.lastIndex`, возвращает следующее совпадение и запоминает позицию после него в `regexp.lastIndex`.
- Если совпадений больше нет, то regexp.exec возвращает null, а для regexp.lastIndex устанавливается значение 0.